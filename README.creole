==Work in Progress!


==Table of Contents
[[https://github.com/adamgreen/pinkySim#overview | Overview]] \\
[[https://github.com/adamgreen/pinkySim#how-to-clone | How to Clone]] \\
[[https://github.com/adamgreen/pinkySim#how-to-build | How to Build]] \\
[[https://github.com/adamgreen/pinkySim#how-to-run | How to Run]] \\
[[https://github.com/adamgreen/pinkySim#unit-test-validation | Unit Test Validation]] \\
[[https://github.com/adamgreen/pinkySim#important-notes | Important Notes]] \\
[[https://github.com/adamgreen/pinkySim#samples | Samples]] \\


==Overview
pinkySim is an ARMv6-M instruction set simulator. It was developed to facilitate the use of Test Driven Development,
TDD, on future projects where the code under test will be written in assembly language.  With this goal in mind it has
//or will have// these features:
* Supports the core ARMv6-M instruction set needed to run unit tests on the developer's host machine as part of the
  automated cross-compile/build process.
* pinkSim itself contains a healthy suite of unit tests:
** Contains >450 unit tests that run as part of the automated build process.
** Covers 100% of the code in pinkySim.c.
** A good proportion of the unit tests have been deployed and validated on actual ARM hardware.
* Supports arm-none-eabi-gdb debugging of Thumb code running in the simulator.
* Will include code coverage abilities.  This will allow for the determination of the level of code coverage obtained
  on assembly language code by its corresponding unit tests.  //This feature will be started in the near future.//


==How to Clone
This project uses submodules (ie. MRI).  Cloning requires a few more steps to get all of the necessary
code.

{{{
git clone --recursive git@github.com:adamgreen/pinkySim.git
}}}

**- or -**

{{{
git clone git@github.com:adamgreen/pinkySim.git
cd pinkSim
git submodule init
git submodule update
cd mri
git submodule init
git submodule update
}}}


== How to Build
pinkySim uses a single non-recursive makefile at the root of the project to build everything.  It supports these top
level targets:
* **all**: This builds the pinkySim code, builds the unit tests, executes the unit tests, and reports the test results.
  This is the default target if no other is provided to make.
* **clean**: Cleans up all ouptut files from any previous builds.  This forces everything to be built on the next make
  run.
* **gcov**: Like the **all** target, this builds all of the pinkySim code and runs the unit tests but it also
  instruments the binaries with code coverage tracking and then reports the code coverage obtained from executing
  the unit tests.
* **test**: This builds and runs some very special tests which aren't required for the main pinkySim funtionality.
  There is a [[https://github.com/adamgreen/pinkySim#unit-test-validation | section below]] related to the unit test
  validation suite run by specifying this target.

Example:\\
{{{make all}}} - Build pinkySim.

The makefile is constructed in such a way that all dependencies for any single target within the build system are known
by GNU Make, including header file dependencies.  This means that the user can specify a specific binary target on the
make command line and it should successfully build it and all of its dependencies.

Examples:\\
{{{make lib/libpinkysim.a}}} - Build the main pinkySim library.\\
{{{make LIBPINKYSIM_tests}}} - Build the main pinkySim library, unit tests, and all required dependencies.\\
{{{make RUN_LIBPINKYSIM_TESTS}}} - This does what the previous example does but also runs the unit tests.\\
{{{make GCOV_LIBPINKYSIM}}} - This is similar to the previous example except that it builds binaries which
include code coverage instrumentation and then reports the resulting code coverage results after running the unit
tests.\\

=== Parallel Build Notes
The user should feel free to use the {{{-j}}} or {{{--jobs}}} command line flag with GNU Make to let it perform the
required build steps in parallel to decrease the build time.  It can be hard to read the output when using this feature
since the output from the parallel executing commands can be interleaved in a random fashion.  If this becomes an issue
when attempting to track down a build issue, then just drop the {{{-j}}} flag while debugging.

Example:\\
{{{make -j4 all}}} - Tells GNU Make that it can have a maximum of 4 commands running at the same time while it is
building the default **all** target.

**Note:** Multiple targets can be specified on the make command line in combination with this parallel build flag except
for the **clean** target which shouldn't be combined with any others.

=== GCOV Code Coverage Notes
All intermediate binaries (*.o and *.a) for code coverage runs are found in the gcov/obj and gcov/lib directories.  If
you want to examine the line by line coverage results for a library like libpinkysim, you would find it in the
gcov/LIBPINKYSIM_tests/ directory.



==How to Run
**Usage:**\\
{{{pinkySim [--ram baseAddress size] [--flash baseAddress size] [--gdbPort tcpPortNumber] [--breakOnStart] imageFilename.bin [args]}}} \\


{{{--ram}}} is used to specify an address range that should be treated as read-write.  More than one of these can be
            specified on the command line to create multiple read-write memory regions.\\
{{{--flash}}} is used to specify and address range that should be treated as read-only.  More than one of these can be
              specified on the command line to create multiple read-only memory regions.\\
{{{--gdbPort}}} can be used to override the default TCP/IP port of 3333 for listening to GDB connections.\\
{{{--breakOnStart}}} can be used to have the simulator halt at the beginning of the reset handler and wait for GDB to
                     connect.\\
{{{imageFilename.bin}}} is the required name of the image to be loaded into memory starting at address 0x00000000.  By
                        default a read-only memory region is created starting at address 0x00000000 and extends large
                        enough to contain the whole image file.  A read-write section will be created based on the
                        initial stack pointer found in the first word of the image file.  This section will start at the
                        nearest 256MB page below this initial SP value and extend to the address just below this initial
                        SP value. This behaviour can be overridden by specifying {{{--ram}}} and {{{--flash}}} options
                        on the command line.  Execution will start at the address found in the second word of this
                        image.\\
{{{[args]}}} are optional arguments to be passed into program running under simulation.

Examples:\\
{{{pinkySim samples/CommandLine_Sample.bin arg1 arg2}}} - Simulates the CommandLine sample, passing in two arguments:
                                                          arg1 and arg2.\\
{{{pinkySim --breakOnStart samples/FileTest_Sample.bin}}} - Simulates the FileTest sample, halts at the beginning of
                                                            Reset_Handler() and waits for GDB to be connected.



==Unit Test Validation
As pinkySim was developed, [[https://github.com/adamgreen/pinkySim/tree/master/libpinkysim/tests | corresponding unit tests]]
were written as well.  However one major concern was that misinterpretations of the ARMv6-M instruction set description
would find their way into both the unit tests and the actual simulator code.  To help reduce the chance of this
occurring, the [[https://github.com/adamgreen/pinkySim/tree/master/libthunk2real | thunk2real]] subproject was created.
This subproject uses a test mock in the place of pinkySim which redirects the process of single stepping to actual ARM
hardware. This is accomplished by connecting the test mock to an an actual ARM Cortex-M3 device (mbed-LPC1768) via the
GDB remote serial protocol.  To run this suite you must:
* Be running the build process from a Macintosh computer running OS X with Xcode installed.
* Build and deploy [[https://github.com/adamgreen/pinkySim/tree/master/libthunk2real/realarm | the realarm firmware]]
  to an mbed-LPC1768 device.
** This mbed device must first be running the [[http://mbed.org/media/uploads/simon/mbedmicrocontroller_21164.if | 21664 interface firmware]].
** Setup the [[https://github.com/adamgreen/gcc4mbed#quick-start | GCC4MBED]] project as a sibling to your pinkySim
   repository clone.
** Build and deploy by running {{{make deploy}}} from the realarm directory.
* Reboot the mbed device.
* Make sure that the mbed device is connected to your Macintosh before running the next step.
* Build the tests.  This can be done by going to the root pinkySim directory on your machine and running
  {{{make test}}}.  This will not only build the tests but it will also detect your connected mbed device and
  automatically run the tests on it.


==Important Notes
Due to the intended use of this simulator, there are several ARMV6-M architectural features which aren't implemented:
* **Not cycle accurate:** The simulator just executes instructions as it encounters them in the code stream and has no
  knowledge of clock cycles.
* **No memory mapped peripherals:** The simulator just issues read/writes to memory.  It doesn't attempt to map special
  memory regions to peripheral registers.  This includes the ARMV6-M specified peripherals such as the NVIC.
* **Doesn't support exception/interrupts:** If the simulator encounters an instruction which would throw an exception,
  it just returns a non-zero return value from the pinkySimStep() routine.  As the simulator doesn't attempt to provide
  any implementation of peripherals, it also doesn't implement support for interrupts that might occur from such
  peripherals.
* **Only runs in Privileged Thread mode:** The simulator doesn't support the switching of the processor into
  Unprivileged mode.  Since exceptions aren't supported, the processor can never enter Handler mode either.
* **Main SP only:** The simulator doesn't support switching to the process stack pointer.



==Samples
The pinkySim project contains a few samples that can be built and executed on the simulator.

|= Sample |= Description |
|  CommandLine | Has a main() function which dumps the argv command line arguments passed into the sample via the pinkySim command line. Upon exit it returns argc, the command argument count, and this will be returned from pinkySim to the launching shell. |
| StdIO | Writes text to stdout and reads input from stdin.  These reads and writes will be redirected to the GDB console if it is connected to pinkySim. Otherwise it uses the pinkySim console. |
| FileTest | Performs file operations such as fopen(), fwrite(), fread(), etc. |

The samples require that the [[https://launchpad.net/gcc-arm-embedded | GNU Tools for ARM Embedded Processors]] C/C++
toolchain be installed and added to your PATH.  To build the samples, run the following commands from the Terminal /
Command Prompt in the root directory of the pinkySim repository:
{{{
cd samples
make all
}}}

The resulting binaries for simulation will be found in the samples directory.  The ELF, map, and disassembly for each sample can be found in the samples/obj directory.

Key files used by the samples:
| pinkySim.ld | Directs the linker to place code in a 256MB FLASH region starting at address 0x00000000 and variables in a 256MB (minus 32 bytes) RAM region staring at 0x10000000.  It also places the isr_vector array from libstartup/Reset.c at the beginning of FLASH where the simulator expects to find the initial stack pointer and reset address. |
| libstartup/Reset.c | Contains the isr_vector array which contains the initial stack pointer value (pointing to the top of RAM) and the Reset_Handler function pointer.  It also contains the Reset_Handler() code which initializes the C runtime and then transfers control to the sample's main(). |
| libstartup/NewlibRetarget.c | Contains the sys call implementations required by the newlib C standard library.  These sys calls are called from newlib when it needs to perform operations such as opening, reading, writing, and closing files on the target system. |
| libstartup/SemihostThunks.s | These ARMV6-M assembly language thunks provide routines that can be called from the NewlibRetarget.c sys calls to transfer execution to pinkySim so that they can be performed on the host system.  A BKPT (breakpoint) instruction with a unique constant is used to signal pinkySim that a specific operation is being requested.  The include/NewlibSemihost.h header defines the BKPT operation constants supported by pinkySim. These thunks also take care of calculating the length of string arguments and setting {{{errno}}} upon return if an error was encountered by the host as it attempted to execute the sys call on behalf of the simulated program. |